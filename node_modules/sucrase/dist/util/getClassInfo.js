"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _keywords = require('../parser/tokenizer/keywords');
var _types = require('../parser/tokenizer/types');







































/**
 * Get information about the class fields for this class, given a token processor pointing to the
 * open-brace at the start of the class.
 */
 function getClassInfo(
  rootTransformer,
  tokens,
  nameManager,
  disableESTransforms,
) {
  const snapshot = tokens.snapshot();

  const headerInfo = processClassHeader(tokens);

  let constructorInitializerStatements = [];
  const instanceInitializerNames = [];
  const staticInitializerNames = [];
  let constructorInsertPos = null;
  const fields = [];
  const rangesToRemove = [];

  const classContextId = tokens.currentToken().contextId;
  if (classContextId == null) {
    throw new Error("Expected non-null class context ID on class open-brace.");
  }

  tokens.nextToken();
  while (!tokens.matchesContextIdAndLabel(_types.TokenType.braceR, classContextId)) {
    if (tokens.matchesContextual(_keywords.ContextualKeyword._constructor) && !tokens.currentToken().isType) {
      ({constructorInitializerStatements, constructorInsertPos} = processConstructor(tokens));
    } else if (tokens.matches1(_types.TokenType.semi)) {
      if (!disableESTransforms) {
        rangesToRemove.push({start: tokens.currentIndex(), end: tokens.currentIndex() + 1});
      }
      tokens.nextToken();
    } else if (tokens.currentToken().isType) {
      tokens.nextToken();
    } else {
      // Either a method or a field. Skip to the identifier part.
      const statementStartIndex = tokens.currentIndex();
      let isStatic = false;
      let isESPrivate = false;
      let isDeclareOrAbstract = false;
      while (isAccessModifier(tokens.currentToken())) {
        if (tokens.matches1(_types.TokenType._static)) {
          isStatic = true;
        }
        if (tokens.matches1(_types.TokenType.hash)) {
          isESPrivate = true;
        }
        if (tokens.matches1(_types.TokenType._declare) || tokens.matches1(_types.TokenType._abstract)) {
          isDeclareOrAbstract = true;
        }
        tokens.nextToken();
      }
      if (isStatic && tokens.matches1(_types.TokenType.braceL)) {
        // This is a static block, so don't process it in any special way.
        skipToNextClassElement(tokens, classContextId);
        continue;
      }
      if (isESPrivate) {
        // Sucrase doesn't attempt to transpile private fields; just leave them as-is.
        skipToNextClassElement(tokens, classContextId);
        continue;
      }
      if (
        tokens.matchesContextual(_keywords.ContextualKeyword._constructor) &&
        !tokens.currentToken().isType
      ) {
        ({constructorInitializerStatements, constructorInsertPos} = processConstructor(tokens));
        continue;
      }

      const nameStartIndex = tokens.currentIndex();
      skipFieldName(tokens);
      if (tokens.matches1(_types.TokenType.lessThan) || tokens.matches1(_types.TokenType.parenL)) {
        // This is a method, so nothing to process.
        skipToNextClassElement(tokens, classContextId);
        continue;
      }
      // There might be a type annotation that we need to skip.
      while (tokens.currentToken().isType) {
        tokens.nextToken();
      }
      if (tokens.matches1(_types.TokenType.eq)) {
        const equalsIndex = tokens.currentIndex();
        // This is an initializer, so we need to wrap in an initializer method.
        const valueEnd = tokens.currentToken().rhsEndIndex;
        if (valueEnd == null) {
          throw new Error("Expected rhsEndIndex on class field assignment.");
        }
        tokens.nextToken();
        while (tokens.currentIndex() < valueEnd) {
          rootTransformer.processToken();
        }
        let initializerName;
        if (isStatic) {
          initializerName = nameManager.claimFreeName("__initStatic");
          staticInitializerNames.push(initializerName);
        } else {
          initializerName = nameManager.claimFreeName("__init");
          instanceInitializerNames.push(initializerName);
        }
        // Fields start at the name, so `static x = 1;` has a field range of `x = 1;`.
        fields.push({
          initializerName,
          equalsIndex,
          start: nameStartIndex,
          end: tokens.currentIndex(),
        });
      } else if (!disableESTransforms || isDeclareOrAbstract) {
        // This is a regular field declaration, like `x;`. With the class transform enabled, we just
        // remove the line so that no output is produced. With the class transform disabled, we
        // usually want to preserve the declaration (but still strip types), but if the `declare`
        // or `abstract` keyword is specified, we should remove the line to avoid initializing the
        // value to undefined.
        rangesToRemove.push({start: statementStartIndex, end: tokens.currentIndex()});
      }
    }
  }

  tokens.restoreToSnapshot(snapshot);
  if (disableESTransforms) {
    // With ES transforms disabled, we don't want to transform regular class
    // field declarations, and we don't need to do any additional tricks to
    // reference the constructor for static init, but we still need to transform
    // TypeScript field initializers defined as constructor parameters and we
    // still need to remove `declare` fields. For now, we run the same code
    // path but omit any field information, as if the class had no field
    // declarations. In the future, when we fully drop the class fields
    // transform, we can simplify this code significantly.
    return {
      headerInfo,
      constructorInitializerStatements,
      instanceInitializerNames: [],
      staticInitializerNames: [],
      constructorInsertPos,
      fields: [],
      rangesToRemove,
    };
  } else {
    return {
      headerInfo,
      constructorInitializerStatements,
      instanceInitializerNames,
      staticInitializerNames,
      constructorInsertPos,
      fields,
      rangesToRemove,
    };
  }
} exports.default = getClassInfo;

/**
 * Move the token processor to the next method/field in the class.
 *
 * To do that, we seek forward to the next start of a class name (either an open
 * bracket or an identifier, or the closing curly brace), then seek backward to
 * include any access modifiers.
 */
function skipToNextClassElement(tokens, classContextId) {
  tokens.nextToken();
  while (tokens.currentToken().contextId !== classContextId) {
    tokens.nextToken();
  }
  while (isAccessModifier(tokens.tokenAtRelativeIndex(-1))) {
    tokens.previousToken();
  }
}

function processClassHeader(tokens) {
  const classToken = tokens.currentToken();
  const contextId = classToken.contextId;
  if (contextId == null) {
    throw new Error("Expected context ID on class token.");
  }
  const isExpression = classToken.isExpression;
  if (isExpression == null) {
    throw new Error("Expected isExpression on class token.");
  }
  let className = null;
  let hasSuperclass = false;
  tokens.nextToken();
  if (tokens.matches1(_types.TokenType.name)) {
    className = tokens.identifierName();
  }
  while (!tokens.matchesContextIdAndLabel(_types.TokenType.braceL, contextId)) {
    // If this has a superclass, there will always be an `extends` token. If it doesn't have a
    // superclass, only type parameters and `implements` clauses can show up here, all of which
    // consist only of type tokens. A declaration like `class A<B extends C> {` should *not* count
    // as having a superclass.
    if (tokens.matches1(_types.TokenType._extends) && !tokens.currentToken().isType) {
      hasSuperclass = true;
    }
    tokens.nextToken();
  }
  return {isExpression, className, hasSuperclass};
}

/**
 * Extract useful information out of a constructor, starting at the "constructor" name.
 */
function processConstructor(tokens)


 {
  const constructorInitializerStatements = [];

  tokens.nextToken();
  const constructorContextId = tokens.currentToken().contextId;
  if (constructorContextId == null) {
    throw new Error("Expected context ID on open-paren starting constructor pa¼ÿôİ¼ÿôİ¼ÿôŞ¼ÿõŞ¼ÿõŞ½ÿôŞ½ÿôŞ½ÿôŞ½ÿôŞ½ÿôŞ½ÿôŞ½ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôŞ¾ÿôß¿ÿôßÀÿôßÀÿõàÁÿõàÁÿõàÁÿõàÂÿõàÃÿõáÄÿõâÆÿæÖÃÿ}`C|                                                                                                                      İÂ©ÓöâÅÿôÛ·ÿôÛ¸ÿôÛ¸ÿôÛ¹ÿóÜ¹ÿóÜ¹ÿóÜ¹ÿôÜºÿôÜºÿôÜºÿôÜ»ÿóÜ»ÿóÜ»ÿóÜ»ÿóİ»ÿôİ»ÿôİ¼ÿóİ¼ÿóİ¼ÿóİ¼ÿóİ¼ÿóİ½ÿóİ½ÿóİ½ÿóİ½ÿóİ½ÿóİ½ÿóİ½ÿóİ½ÿóİ½ÿóİ½ÿóİ½ÿóİ½ÿóİ½ÿóİ½ÿóİ½ÿóİ½ÿóİ½ÿóİ¾ÿóİ½ÿóİ½ÿóİ½ÿóİ½ÿóİ½ÿóİ½ÿóİ½ÿóİ½ÿóİ½ÿóİ½ÿóİ½ÿóİ½ÿóİ½ÿóİ½ÿóİ¾ÿóŞ¾ÿóŞ¿ÿôŞÀÿôßÀÿôßÀÿôßÁÿôßÂÿôàÄÿåÔÂÿ}`C|                                                                                                                      Ñ¸ ÓçÔ¸ÿäÌ«ÿäÌ¬ÿäÌ¬ÿäÌ¬ÿäÌ¬ÿãÍ­ÿãÍ­ÿäÍ­ÿäÍ®ÿäÍ®ÿäÍ®ÿäÍ®ÿãÍ¯ÿãÍ¯ÿãÎ¯ÿãÎ¯ÿäÎ¯ÿäÎ°ÿãÎ°ÿãÎ°ÿãÎ°ÿãÎ°ÿãÎ°ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ±ÿãÎ²ÿãÏ²ÿäÏ²ÿäÏ³ÿäĞ³ÿäĞ´ÿäĞµÿ×Ç¶ÿv[A}                                                                                                                  ²L
¿vàÉ¬„ÿÆ§|ÿÆ§|ÿÆ§|ÿÆ§|ÿÆ§}ÿÆ§}ÿÆ§}ÿÆ§}ÿÅ§}ÿÆ§~ÿÅ§}ÿÅ¦}ÿÅ¦~ÿÄ¦}ÿÄ¦}ÿÄ¦}ÿÃ¦}ÿÃ¦}ÿÃ¥}ÿÂ¥}ÿÂ¥}ÿÂ¥}ÿÁ¤}ÿÁ¤}ÿÁ¤}ÿÀ¤}ÿÀ£|ÿ¿£|ÿ¿£|ÿ¿¢|ÿ¾¢|ÿ¾¢|ÿ¾¢|ÿ½¡{ÿ½¡{ÿ½¡{ÿ¼ {ÿ¼ {ÿ¼ {ÿ» {ÿ»Ÿzÿ»ŸzÿºŸzÿºŸzÿºzÿºzÿ¹zÿ¹yÿ¹yÿ¹yÿ¹yÿ¸yÿ¸yÿ¸yÿ¸yÿ¸yÿ¸zÿ¸zÿ¸zÿ¹{ÿ¹{ÿ¹{ÿ³›}ÿ}^9œ                                                                                                                  ·G ¹škÿ³—sÿµ˜qÿ´–tÿ³–sÿ¶•rÿ´•rÿµ˜rÿµ˜rÿµ˜rÿ´–qÿ³˜oÿ´—qÿ¶•rÿ²—qÿ±–qÿ³”pÿ³—pÿ³•nÿ±“nÿ±“nÿ¯’mÿ°kÿ­“kÿ®iÿ®gÿ¯Šhÿ¯hÿ¯Œfÿ«ŒhÿªŠeÿª‰dÿ«Šbÿ¨‡dÿªˆaÿ©ˆaÿ«…_ÿ©„^ÿ¦…]ÿ¤‚^ÿ¥[ÿ¥‚Zÿ¥Zÿ£Xÿ¥€Wÿ¤Wÿ¡Wÿ¤}Vÿ¡Tÿ¡|Wÿ |Vÿ¡{Tÿ¡zSÿ {Sÿ¤{Qÿ¢{Sÿ¢|Uÿ¢ySÿ¢|Rÿ |Rÿ¡|Rÿ£|Qÿ¢zTÿ£{Rÿ£zQÿ“n?à                                                                                                                  ·G Àrÿ½˜mÿ¾™mÿ¾šnÿ¾šnÿ»šqÿ¼œqÿ¼›nÿ»œrÿ½qÿ»›rÿ¾šsÿ½rÿ¼›sÿ»œpÿ¹œrÿºšpÿ¹šqÿ¹—qÿ¹™pÿ¹—pÿ½˜oÿ¸˜kÿ¹—kÿ¹—nÿ·•kÿ¹–jÿ·•iÿ¹‘hÿ·gÿ¸’eÿ´eÿ²dÿ²aÿ±`ÿ²‰\ÿ³‹]ÿ±‹]ÿ±‰]ÿ±‰\ÿ­‡Yÿ°‡Zÿ­ƒWÿ¬ƒXÿªƒWÿ­„Tÿ­Sÿ©€Sÿª€Rÿ©Tÿ©}Pÿ§|Rÿ§|Oÿ¦}Lÿ¨|Lÿ¦{Nÿ¦}Mÿ§~Oÿ¦|Nÿ©~Nÿ¨{Lÿ¦~Pÿ§~Nÿ¥{Lÿ¨zLÿ—r@à                                                                                                                  ·G ÆŸuÿÃ›nÿÅsÿÄtÿÇrÿÅtÿÈ¢uÿÅtÿË sÿÇ¢uÿÇ¤wÿÇ¥xÿÆ£xÿÆ£xÿÆ¥yÿÈ¤yÿÉ¥wÿÊ¥xÿÅ¥xÿÉ¤zÿÈ¤wÿÅ¤wÿÄ£wÿÆ¤vÿÅ tÿÇ sÿÄ tÿÅ sÿÃŸtÿÃŸqÿÁœqÿÂqÿÁ™nÿ¿šmÿÀ™jÿ¾™lÿ¿”hÿ¾—iÿ¾–hÿ¼–eÿ¼”fÿ¸’dÿº‘fÿ¹‘aÿ»]ÿ¶`ÿ¹aÿ·Œ\ÿµŠ^ÿ¶Œ[ÿµŠYÿµ‰Yÿ³†Wÿ´‡Uÿ´ˆSÿ²…Xÿ´ƒUÿ¯„Tÿ±‚Rÿ°…Qÿ°‚Rÿ°ƒSÿ®ƒRÿ°‚Sÿ®€Rÿ›rBà                                                                                                                  ·G ÇuÿÈœnÿÉpÿÍœsÿÈpÿÉŸpÿÊ¡uÿÉ¢sÿÊ£wÿÌ£vÿË£tÿË£wÿÍ¥xÿÏ¥zÿÍ¤yÿË¦{ÿÊ¨|ÿÍ§{ÿÍ¦|ÿÌ¨{ÿÎ¦{ÿË§{ÿÌ¨{ÿÌ¦wÿÈ¥zÿË§yÿÊ¤zÿÌ§zÿÊ¤yÿÌ£vÿË£vÿÇ¡uÿË¤uÿÇ¡sÿÅ£rÿÆrÿÈŸsÿÅŸpÿÃœoÿÇmÿÀšlÿ¿˜kÿ¿šhÿÀ˜iÿ¼•gÿ¾”hÿ¾—fÿ¾dÿ»‘dÿ»dÿ¹aÿº_ÿ¸`ÿ¸`ÿ¸]ÿ»Š[ÿ¸ˆZÿ¶‰[ÿ·ŠYÿ¶ˆUÿ´ˆUÿ²‡Tÿ³ˆWÿ±„Tÿ²‚QÿvCà                                                                                                                  ·G É sÿÇœnÿÊsÿËqÿÆ›qÿÇ qÿÉoÿÈqÿÊsÿÊ¢rÿÉ sÿÍ sÿÊŸrÿÊ¢tÿÌ£vÿÊ¤uÿÊ¦vÿÌ£xÿÏ§zÿË§{ÿÍ¥yÿÍ¤yÿÍ¦zÿÏ¤yÿÌ§zÿÍ¨zÿÍ©{ÿÎ¨{ÿÍ§{ÿË¦yÿË§{ÿÊ¤yÿÌ¥zÿÌ¤xÿÊ£uÿÈ¤vÿÇ¢sÿÆ£vÿË tÿÆ sÿÅŸoÿÇpÿÆœnÿÃnÿÁkÿÃšlÿÂ™kÿÀ—jÿ¿˜iÿÀ•hÿ¾•fÿ¼•fÿ¼’dÿ»’bÿ½dÿº‘^ÿº_ÿ¹\ÿ¹Œ]